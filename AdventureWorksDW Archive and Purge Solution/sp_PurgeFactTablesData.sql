USE AdventureWorksDW2017
GO
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'Archive' AND ROUTINE_NAME = 'sp_PurgeFactTablesData')
DROP PROCEDURE ARCHIVE.sp_PurgeFactTablesData
GO
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE [SCHEMA_NAME] = 'Archive') 
DROP SCHEMA Archive
GO
CREATE SCHEMA Archive;
GO
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'Archive' AND ROUTINE_NAME = 'sp_PurgeFactTablesData')
DROP PROCEDURE ARCHIVE.sp_PurgeFactTablesData
GO
-- =============================================
-- Author:		NARA
-- Create date: 01/1/2019
-- Description:	MOVE THE DATA TO ARCHIVE AND PURGE FROM ONLINE BASED ON THE CONFIGURATION MENTIONED IN TABLE
-- =============================================
CREATE PROCEDURE ARCHIVE.sp_PurgeFactTablesData
	@TABLE_NAME SYSNAME
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ONLINE_DB SYSNAME, @TABLE_SCHEMA SYSNAME, @FILTER_COLUMN SYSNAME,   @RETENTION_PERIOD INT, @BATCH_SIZE INT, @ARCHIVE_DB SYSNAME,@KEY_COLUMNS NVARCHAR(MAX), @LINKEDSERVER SYSNAME 
		
	SELECT TOP 1 @ONLINE_DB =ONLINE_DB,@TABLE_SCHEMA =TABLE_SCHEMA,@FILTER_COLUMN=FILTER_COLUMN,@RETENTION_PERIOD=RETENTION_PERIOD,@BATCH_SIZE=BATCH_SIZE, @ARCHIVE_DB=ARCHIVE_DB,@KEY_COLUMNS = KEY_COLUMNS,@LINKEDSERVER =ISNULL(LINKEDSERVER,'')
	FROM  dbo.[ArchiveFactTablesConfig] (NOLOCK) WHERE TABLE_NAME =@TABLE_NAME AND ISACTIVE= 1

	IF @TABLE_SCHEMA IS NULL
	GOTO TABLE_IS_NOT_ACTIVE;

	--GET COLUMN CONDTION this is to PURGE THE DATA
	DECLARE @COLUMN_CONDITION NVARCHAR(MAX)
	IF (OBJECT_ID('tempdb..#KEY_COLUMNS') IS NOT NULL) DROP TABLE #KEY_COLUMNS
	SELECT  1 AS ID,   'ON_LINE.' + item + ' = ARCHIVE. '+ item + ' AND ' AS COLUMN_CONDITION  INTO #KEY_COLUMNS
	FROM [fnSplit] (@KEY_COLUMNS,',') 
 
	SELECT DISTINCT @COLUMN_CONDITION = SUBSTRING(STUFF(REPLACE((SELECT '~~' + (COLUMN_CONDITION) AS 'data()' FROM  #KEY_COLUMNS A WHERE A.ID = B.ID  FOR XML PATH('')),'~~',''), 1, 0, '') ,1, 
	LEN(STUFF(REPLACE((SELECT '~~' + (COLUMN_CONDITION) AS 'data()' FROM  #KEY_COLUMNS A WHERE A.ID = B.ID  FOR XML PATH('')),'~~',''), 1, 0, ''))-3)
	FROM #KEY_COLUMNS B 
	--SELECT @COLUMN_CONDITION

	--TABLE CHECK
	DECLARE @TABLE_CHECK_SQLCMD NVARCHAR(MAX),@TABLE_CNT INT--,@TABLE_NAME SYSNAME
	
	SET @TABLE_CHECK_SQLCMD = 'SELECT @TABLE_CNT = COUNT(*) FROM '+@ONLINE_DB+'.INFORMATION_SCHEMA.TABLES  ON_LINE 
	JOIN '+CASE WHEN @LINKEDSERVER = '' THEN '' ELSE @LINKEDSERVER END+@ARCHIVE_DB+'.INFORMATION_SCHEMA.TABLES ARCHIVE ON ON_LINE.TABLE_NAME = ARCHIVE.TABLE_NAME AND ON_LINE.TABLE_SCHEMA = ARCHIVE.TABLE_SCHEMA
	WHERE ON_LINE.TABLE_NAME  =  ''' + @TABLE_NAME+''''
	EXEC SP_EXECUTESQL @TABLE_CHECK_SQLCMD, N'@TABLE_CNT INT OUTPUT', @TABLE_CNT OUT
	
	DECLARE @TABLE_CHECK_ERROR NVARCHAR(MAX) = N'PLEASE CHECK WHETHER TABLE IS AVAILABLE IN ARCHIVE DATABASE, IF NOT PLEASE CREATE THE '+ @TABLE_NAME+' TABLE BEFORE RE-EXECUTE SPROC OR PACKAGE'
	IF (@TABLE_CNT = 0)
	GOTO TABLE_CHECK_FAILURE;
	--RAISERROR (@TABLE_CHECK_ERROR,15,1,1) WITH NOWAIT

	--CARDINALITY CHECKING (No Of Column Check)
	DECLARE @CARDINALITY_SQLCMD NVARCHAR(MAX),@ONLINE_COUNT INT,@ARCHIVE_COUNT INT,@ARE_COLUMN_NAMES_MATCH INT--,@TABLE_NAME SYSNAME
	--SET @TABLE_NAME ='fBingoRatingFact'
	SET @CARDINALITY_SQLCMD = 'SELECT @ONLINE_COUNT =COUNT(DISTINCT ON_LINE.COLUMN_NAME), @ARCHIVE_COUNT =COUNT(DISTINCT ARCHIVE.COLUMN_NAME) , @ARE_COLUMN_NAMES_MATCH=COUNT(DISTINCT ARCHIVE_COL_NAMES.COLUMN_NAME)
	FROM '+@ONLINE_DB+'.INFORMATION_SCHEMA.COLUMNS ON_LINE 
	LEFT JOIN '+CASE WHEN @LINKEDSERVER = '' THEN '' ELSE @LINKEDSERVER END+@ARCHIVE_DB+'.INFORMATION_SCHEMA.COLUMNS ARCHIVE ON 	ON_LINE.TABLE_SCHEMA = ARCHIVE.TABLE_SCHEMA AND  ON_LINE.TABLE_NAME= ARCHIVE.TABLE_NAME
	LEFT JOIN '+CASE WHEN @LINKEDSERVER = '' THEN '' ELSE @LINKEDSERVER END+@ARCHIVE_DB+'.INFORMATION_SCHEMA.COLUMNS ARCHIVE_COL_NAMES ON 	ON_LINE.TABLE_SCHEMA = ARCHIVE_COL_NAMES.TABLE_SCHEMA 
	AND  ON_LINE.TABLE_NAME= ARCHIVE_COL_NAMES.TABLE_NAME AND  ON_LINE.COLUMN_NAME= ARCHIVE_COL_NAMES.COLUMN_NAME
	WHERE ON_LINE.TABLE_NAME = ''' + @TABLE_NAME+''''
	EXEC SP_EXECUTESQL @CARDINALITY_SQLCMD, N'@ONLINE_COUNT INT OUTPUT,@ARCHIVE_COUNT INT OUTPUT,@ARE_COLUMN_NAMES_MATCH INT OUTPUT', @ONLINE_COUNT OUT,@ARCHIVE_COUNT OUT,@ARE_COLUMN_NAMES_MATCH OUT
	--SELECT  @ONLINE_COUNT , @ARCHIVE_COUNT 
	DECLARE @CARDINALITY_ERROR NVARCHAR(MAX) =N'PLEASE CHECK WHETHER THE NUMBER OF COLUMNNS IN THE '+@TABLE_NAME+' TABLE ARE MATCHING BETWEEN BI AND ARCHIVE DATABASES, ADD THE MISSING COLUMN BEFORE RE-EXECUTE THE SPROC OR PACKAGE ' 
	DECLARE @COLUMN_NAMES_ERROR NVARCHAR(MAX) =N'PLEASE CHECK WHETHER COLUMN NAMES IN THE '+@TABLE_NAME+' TABLE ARE MATCHING BETWEEN BI AND ARCHIVE DATABASES, MAKE SURE COLUMN NAMES ARE MATCHING BEFORE RE-EXECUTE THE SPROC OR PACKAGE ' 
	
	IF @ONLINE_COUNT <> @ARCHIVE_COUNT
	GOTO CARDINALITY_FAILURE1;
	--RAISERROR (@CARDINALITY_ERROR,15,1,1) WITH NOWAIT
	ELSE
	IF @ONLINE_COUNT = @ARCHIVE_COUNT AND @ONLINE_COUNT <> @ARE_COLUMN_NAMES_MATCH
	GOTO CARDINALITY_FAILURE2;
	--RAISERROR (@COLUMN_NAMES_ERROR,15,1,1) WITH NOWAIT
	--GOTO CARDINALITY_FAILURE;

	--IDENTITY CHECKING
	DECLARE @IDENTITY_SQLCMD NVARCHAR(MAX)='',@IDENTITY_FLAG INT --,@TABLE_NAME SYSNAME,@ONLINE_DB SYSNAME='BallyBI'
	SET @IDENTITY_SQLCMD = '
	SELECT @IDENTITY_FLAG = COUNT(*) FROM '+@ONLINE_DB+'.INFORMATION_SCHEMA.COLUMNS 
	WHERE COLUMNPROPERTY(OBJECT_ID(QUOTENAME(TABLE_SCHEMA)+''.''+QUOTENAME(TABLE_NAME)),COLUMN_NAME,''ISIDENTITY'') = 1 AND 
	TABLE_NAME =''' + @TABLE_NAME+''''
	EXEC SP_EXECUTESQL  @IDENTITY_SQLCMD, N'@IDENTITY_FLAG INT OUTPUT', @IDENTITY_FLAG OUT
	--SELECT  @IDENTITY_FLAG
	IF @IDENTITY_FLAG =1
	SET @IDENTITY_SQLCMD = 'SET IDENTITY_INSERT ' +CASE WHEN @LINKEDSERVER = '' THEN '' ELSE @LINKEDSERVER END+@ARCHIVE_DB+'.'+@TABLE_SCHEMA+'.'+@TABLE_NAME + ' ' --ON/OFF MANAGE WITH IN WHILE LOOP
	
	--GET NUMBER OF DATES BASED ON RETENTION PERIOD
	DECLARE @NO_OF_LOOPS_SQLCMD NVARCHAR(MAX)--,@RETENTION_PERIOD INT=1390,@BATCH_SIZE INT = 10000
	SET @NO_OF_LOOPS_SQLCMD = '
	SELECT '+@FILTER_COLUMN+',COUNT(*) ROWCNT,CASE WHEN '+CAST(@BATCH_SIZE AS VARCHAR)+' >= COUNT(*) THEN 1 ELSE CEILING(COUNT(*)*1.0/'+CAST(@BATCH_SIZE AS VARCHAR)+')  END NO_OF_LOOPS 
	FROM '+@ONLINE_DB+'.'+@TABLE_SCHEMA+'.'+@TABLE_NAME +' 
	WHERE DATEDIFF(DD,'+@FILTER_COLUMN+',GETDATE()) > '+CAST(@RETENTION_PERIOD AS VARCHAR) +'
	GROUP BY '+@FILTER_COLUMN+' ORDER BY 1'

	IF(OBJECT_ID('tempdb..#GET_NO_OF_LOOPS') is not null) DROP TABLE #GET_NO_OF_LOOPS
	CREATE TABLE #GET_NO_OF_LOOPS (PURGED_DATE DATE,ROWCNT INT,NO_OF_LOOPS INT)
	INSERT #GET_NO_OF_LOOPS EXEC SP_EXECUTESQL @NO_OF_LOOPS_SQLCMD
	--SELECT * FROM #GET_NO_OF_LOOPS

	--GET COLUMN LIST
	DECLARE @COLUMN_LIST_SQLCMD NVARCHAR(MAX),@COLUMN_LIST NVARCHAR(MAX) 
	SET @COLUMN_LIST_SQLCMD = N'
	SELECT DISTINCT  @COLUMN_LIST = STUFF(REPLACE((SELECT ''~~'' + QUOTENAME(SC.COLUMN_NAME) AS ''data()'' 
	FROM   '+@ONLINE_DB+'. INFORMATION_SCHEMA.COLUMNS SC 
	WHERE  SC.TABLE_SCHEMA = C.TABLE_SCHEMA AND SC.TABLE_NAME = C.TABLE_NAME 
	--AND COLUMNPROPERTY(OBJECT_ID(QUOTENAME(SC.TABLE_SCHEMA) + ''.'' + QUOTENAME(SC.TABLE_NAME)), SC.COLUMN_NAME, ''ISIDENTITY'') <> 1 
	AND COLUMNPROPERTY(OBJECT_ID(QUOTENAME(SC.TABLE_SCHEMA) + ''.'' + QUOTENAME(SC.TABLE_NAME)), SC.COLUMN_NAME, ''ISCOMPUTED'') <> 1 
	 FOR XML PATH('''')),''~~'','', ''), 1, 2, '''') --as [COLUMNS_LIST]
	FROM   '+@ONLINE_DB+'. INFORMATION_SCHEMA.TABLES T 
		   JOIN '+@ONLINE_DB+'. INFORMATION_SCHEMA.COLUMNS C 
			 ON C.TABLE_SCHEMA = T.TABLE_SCHEMA 
				AND C.TABLE_NAME = T.TABLE_NAME 
	WHERE  TABLE_TYPE = ''BASE TABLE'' 
	AND T.TABLE_NAME = '''+@TABLE_NAME+''''
	EXEC SP_EXECUTESQL  @COLUMN_LIST_SQLCMD, N'@COLUMN_LIST NVARCHAR(MAX) OUTPUT', @COLUMN_LIST OUT
	--SELECT @COLUMN_LIST;

	--STARTING OF WHILE LOOP
	WHILE EXISTS (SELECT * FROM #GET_NO_OF_LOOPS)
	BEGIN
		DECLARE @PURGED_DATE DATE, @NO_OF_LOOPS INT,@COPY_SQLCMD NVARCHAR(MAX),@INSERT_SQLCMD NVARCHAR(MAX),@DELETE_SQLCMD NVARCHAR(MAX),@SPID SYSNAME,@IS_SINGLE_LOOP INT =0
		SET @SPID = @@SPID	
		
		DECLARE @GLOBAL_TEMP_DROP NVARCHAR(MAX)
		SET @GLOBAL_TEMP_DROP = 'IF(OBJECT_ID(''tempdb..##COPY_DATA_'+@SPID+''') is not null) DROP TABLE ##COPY_DATA_'+@SPID+ ' '
		--PRINT 	@GLOBAL_TEMP_DROP
		SELECT TOP 1 @PURGED_DATE =PURGED_DATE,@NO_OF_LOOPS = NO_OF_LOOPS FROM #GET_NO_OF_LOOPS
		SET @INSERT_SQLCMD = CASE WHEN @IDENTITY_FLAG =1 THEN @IDENTITY_SQLCMD + ' ON ' ELSE ''END
							+ ' INSERT '+CASE WHEN @LINKEDSERVER = '' THEN '' ELSE @LINKEDSERVER END+@ARCHIVE_DB+'.' +@TABLE_SCHEMA + '.'+@TABLE_NAME + '('+@COLUMN_LIST+') 
								SELECT '+@COLUMN_LIST + '  FROM ##COPY_DATA_'+@SPID+' '
							+CASE WHEN @IDENTITY_FLAG =1 THEN @IDENTITY_SQLCMD + ' OFF ' ELSE ''END						
		
		SET @DELETE_SQLCMD = ' DELETE  ON_LINE FROM '+@ONLINE_DB+'.' +@TABLE_SCHEMA + '.'+@TABLE_NAME + ' ON_LINE WHERE EXISTS (SELECT * FROM  ##COPY_DATA_'+@SPID+' ARCHIVE WHERE ' + @COLUMN_CONDITION + ' ) ' 
		
		IF @NO_OF_LOOPS =1
		BEGIN
		SET @IS_SINGLE_LOOP = 1 
		END
		IF @IS_SINGLE_LOOP =1
		BEGIN
			--INSERT THE LOG
			INSERT dbo.AdventureWorksDW_Archive_Log (TABLE_SCHEMA,TABLE_NAME,PURGED_DATE,ROWCNT,BATCH_SIZE,StartAt,EndAt)
			SELECT @TABLE_SCHEMA,@TABLE_NAME,@PURGED_DATE,NULL,@BATCH_SIZE,GETDATE(),NULL

			SET @COPY_SQLCMD = 'SELECT  * INTO ##COPY_DATA_'+@SPID+'  FROM '+@ONLINE_DB+'.'+@TABLE_SCHEMA+'.'+@TABLE_NAME +'  (NOLOCK) WHERE  '+@FILTER_COLUMN +'  = '''+ CAST(@PURGED_DATE AS NVARCHAR) + ''''
			--DROP THE GLOBAL TEMP TABLE
			EXEC SP_EXECUTESQL @GLOBAL_TEMP_DROP	
			--COPY THE DATA
			EXEC SP_EXECUTESQL @COPY_SQLCMD			
			--MOVE THE DATA
			EXEC SP_EXECUTESQL @INSERT_SQLCMD
			--DELETE THE DATA
			EXEC SP_EXECUTESQL @DELETE_SQLCMD
			
			UPDATE dbo.AdventureWorksDW_Archive_Log  SET ROWCNT=@@ROWCOUNT, EndAt = GETDATE() WHERE TABLE_NAME = @TABLE_NAME AND TABLE_SCHEMA = @TABLE_SCHEMA AND PURGED_DATE= @PURGED_DATE AND EndAt IS NULL AND ROWCNT IS NULL
			
			--DROP THE GLOBAL TEMP TABLE
			EXEC SP_EXECUTESQL @GLOBAL_TEMP_DROP
		END 
		WHILE (@NO_OF_LOOPS>=1 AND @IS_SINGLE_LOOP =0)
		BEGIN 
			--INSERT THE LOG
			INSERT dbo.AdventureWorksDW_Archive_Log (TABLE_SCHEMA,TABLE_NAME,PURGED_DATE,ROWCNT,BATCH_SIZE,StartAt,EndAt)
			SELECT @TABLE_SCHEMA,@TABLE_NAME,@PURGED_DATE,NULL,@BATCH_SIZE,GETDATE(),NULL
			
			SET @COPY_SQLCMD = 'SELECT  TOP '+CAST(@BATCH_SIZE AS NVARCHAR) +' * INTO ##COPY_DATA_'+@SPID+' FROM '+@ONLINE_DB+'.'+@TABLE_SCHEMA+'.'+@TABLE_NAME +'  (NOLOCK) WHERE '+@FILTER_COLUMN +'  =  '''+ CAST(@PURGED_DATE AS NVARCHAR) + ''''
			--DROP THE GLOBAL TEMP TABLE
			EXEC SP_EXECUTESQL @GLOBAL_TEMP_DROP
			--COPY THE DATA
			EXEC SP_EXECUTESQL @COPY_SQLCMD
			--MOVE THE DATA
			EXEC SP_EXECUTESQL @INSERT_SQLCMD
			--DELETE THE DATA
			EXEC SP_EXECUTESQL @DELETE_SQLCMD

			--UPDATE THE LOG
			UPDATE dbo.AdventureWorksDW_Archive_Log SET ROWCNT=@@ROWCOUNT, EndAt = GETDATE() WHERE TABLE_NAME = @TABLE_NAME AND TABLE_SCHEMA = @TABLE_SCHEMA AND PURGED_DATE= @PURGED_DATE  AND EndAt IS NULL AND ROWCNT IS NULL

			SET @NO_OF_LOOPS = @NO_OF_LOOPS -1
			--DROP THE GLOBAL TEMP TABLE
			EXEC SP_EXECUTESQL @GLOBAL_TEMP_DROP
			
		END 

		DELETE #GET_NO_OF_LOOPS WHERE PURGED_DATE = @PURGED_DATE
	END

	UPDATE  dbo.[ArchiveFactTablesConfig]  SET LAST_OUTCOME = 'SUCCESS' ,LAST_UPDATE = GETDATE() WHERE TABLE_NAME = @TABLE_NAME

	CARDINALITY_FAILURE1:
	IF @ONLINE_COUNT <> @ARCHIVE_COUNT
	UPDATE  dbo.[ArchiveFactTablesConfig]  SET LAST_OUTCOME = @CARDINALITY_ERROR,LAST_UPDATE = GETDATE() WHERE TABLE_NAME = @TABLE_NAME
	CARDINALITY_FAILURE2:
	IF @ONLINE_COUNT = @ARCHIVE_COUNT AND @ONLINE_COUNT <> @ARE_COLUMN_NAMES_MATCH
	UPDATE  dbo.[ArchiveFactTablesConfig]  SET LAST_OUTCOME = @COLUMN_NAMES_ERROR,LAST_UPDATE = GETDATE() WHERE TABLE_NAME = @TABLE_NAME
	
	TABLE_CHECK_FAILURE:
	IF (@TABLE_CNT = 0)
	UPDATE  dbo.[ArchiveFactTablesConfig]  SET LAST_OUTCOME = @TABLE_CHECK_ERROR,LAST_UPDATE = GETDATE() WHERE TABLE_NAME = @TABLE_NAME
	
	TABLE_IS_NOT_ACTIVE:
	
	

END
GO



